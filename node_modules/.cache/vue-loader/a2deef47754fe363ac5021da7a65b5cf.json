{"remainingRequest":"/home/justin/Desktop/CICMS/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/justin/Desktop/CICMS/src/components/GameCanvas.vue?vue&type=script&lang=js","dependencies":[{"path":"/home/justin/Desktop/CICMS/src/components/GameCanvas.vue","mtime":1771874482536},{"path":"/home/justin/Desktop/CICMS/node_modules/cache-loader/dist/cjs.js","mtime":1771824225125},{"path":"/home/justin/Desktop/CICMS/node_modules/babel-loader/lib/index.js","mtime":1771824228601},{"path":"/home/justin/Desktop/CICMS/node_modules/cache-loader/dist/cjs.js","mtime":1771824225125},{"path":"/home/justin/Desktop/CICMS/node_modules/vue-loader/lib/index.js","mtime":1771824228358}],"contextDependencies":[],"result":["\nimport wsService from '../services/websocket';\n\nconst TILE_SIZE = 32;\nconst TILE_COLORS = {\n  0: '#4a7c3f',   // grass\n  1: '#2b5eab',   // water\n  2: '#6e6e6e',   // mountain\n  3: '#2d5a1b',   // tree\n  4: '#8b7355',   // path\n  5: '#a08060',   // wall\n  6: '#444444',   // mine\n  7: '#c8a228',   // bank\n  8: '#8a5a2a',   // shop\n  9: '#c8b87a',   // sand\n  10: '#5a8f3a',  // flower\n};\n\n\nexport default {\n  name: 'GameCanvas',\n  data() {\n    return {\n      canvas: null,\n      ctx: null,\n      animFrame: null,\n      cameraX: 0,\n      cameraY: 0,\n      mouseCol: -1,\n      mouseRow: -1,\n      animTick: 0,\n      lastFrame: 0,\n      // Pre-compute map for rendering\n      worldMap: null,\n      hoverEntity: null,\n    };\n  },\n  computed: {\n    player() {\n      return this.$store.state.player;\n    },\n    otherPlayers() {\n      return this.$store.state.world.otherPlayers;\n    },\n    npcs() {\n      return this.$store.state.world.npcs;\n    },\n    worldItems() {\n      return this.$store.state.world.worldItems;\n    },\n    survival() {\n      return this.$store.state.world.survival;\n    },\n  },\n  mounted() {\n    this.canvas = this.$refs.canvas;\n    this.ctx = this.canvas.getContext('2d');\n    this.resize();\n    window.addEventListener('resize', this.resize);\n\n    // Import map from constants\n    import(/* webpackChunkName: \"constants\" */ '../../server/shared/constants.js')\n      .catch(() => {\n        // Fallback: generate a simple map\n        this.worldMap = this.generateFallbackMap();\n      })\n      .then((mod) => {\n        if (mod) this.worldMap = mod.WORLD_MAP;\n        this.startLoop();\n      });\n  },\n  beforeDestroy() {\n    window.removeEventListener('resize', this.resize);\n    if (this.animFrame) cancelAnimationFrame(this.animFrame);\n  },\n  methods: {\n    resize() {\n      const container = this.$el.parentElement;\n      this.canvas.width = container.clientWidth;\n      this.canvas.height = container.clientHeight;\n    },\n\n    generateFallbackMap() {\n      // 40x32 grass map with paths and water\n      const cols = 40, rows = 32;\n      const map = [];\n      for (let r = 0; r < rows; r++) {\n        const row = [];\n        for (let c = 0; c < cols; c++) {\n          if (r === 0 || r === rows - 1 || c === 0 || c === cols - 1) row.push(2);\n          else if (r === 6 || r === 12 || r === 20) row.push(4);\n          else if (c === 19) row.push(4);\n          else if (c < 4 && r > 12 && r < 22) row.push(1);\n          else row.push(0);\n        }\n        map.push(row);\n      }\n      return map;\n    },\n\n    startLoop() {\n      const loop = (timestamp) => {\n        const delta = timestamp - this.lastFrame;\n        this.lastFrame = timestamp;\n        this.animTick = timestamp;\n        this.update(delta);\n        this.render();\n        this.animFrame = requestAnimationFrame(loop);\n      };\n      this.animFrame = requestAnimationFrame(loop);\n    },\n\n    update() {\n      // Update camera to follow player\n      if (!this.player || !this.canvas) return;\n\n      const targetCamX = this.player.x - this.canvas.width / 2;\n      const targetCamY = this.player.y - this.canvas.height / 2;\n\n      // Smooth camera\n      const lerp = 0.12;\n      this.cameraX += (targetCamX - this.cameraX) * lerp;\n      this.cameraY += (targetCamY - this.cameraY) * lerp;\n\n      // Clamp camera\n      if (this.worldMap) {\n        const mapW = this.worldMap[0].length * TILE_SIZE;\n        const mapH = this.worldMap.length * TILE_SIZE;\n        this.cameraX = Math.max(0, Math.min(this.cameraX, mapW - this.canvas.width));\n        this.cameraY = Math.max(0, Math.min(this.cameraY, mapH - this.canvas.height));\n      }\n    },\n\n    render() {\n      if (!this.ctx || !this.canvas) return;\n      const ctx = this.ctx;\n      const w = this.canvas.width;\n      const h = this.canvas.height;\n\n      ctx.clearRect(0, 0, w, h);\n      ctx.save();\n      ctx.translate(-Math.floor(this.cameraX), -Math.floor(this.cameraY));\n\n      this.renderMap(ctx);\n      this.renderWorldItems(ctx);\n      this.renderNPCs(ctx);\n      this.renderOtherPlayers(ctx);\n      this.renderPlayer(ctx);\n      this.renderHoverHighlight(ctx);\n\n      ctx.restore();\n      \n      this.renderNightOverlay(ctx, w, h);\n    },\n\n    renderMap(ctx) {\n      if (!this.worldMap) return;\n\n      const startCol = Math.max(0, Math.floor(this.cameraX / TILE_SIZE) - 1);\n      const startRow = Math.max(0, Math.floor(this.cameraY / TILE_SIZE) - 1);\n      const endCol = Math.min(this.worldMap[0].length, startCol + Math.ceil(this.canvas.width / TILE_SIZE) + 2);\n      const endRow = Math.min(this.worldMap.length, startRow + Math.ceil(this.canvas.height / TILE_SIZE) + 2);\n\n      for (let row = startRow; row < endRow; row++) {\n        for (let col = startCol; col < endCol; col++) {\n          let tile = this.worldMap[row][col];\n          \n          // Check dynamic tiles\n          if (this.survival && this.survival.dynamicTiles) {\n            const dynamicTile = this.survival.dynamicTiles[`${col},${row}`];\n            if (dynamicTile !== undefined) tile = dynamicTile;\n          }\n\n          const px = col * TILE_SIZE;\n          const py = row * TILE_SIZE;\n\n          // Base tile color\n          ctx.fillStyle = TILE_COLORS[tile] || '#444';\n          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\n\n          // Tile details/decorations\n          this.renderTileDetail(ctx, tile, px, py, col, row);\n        }\n      }\n    },\n\n    renderTileDetail(ctx, tile, px, py, col, row) {\n      const t = this.animTick;\n\n      switch(tile) {\n        case 0: // Grass - subtle variation\n          if ((col + row) % 3 === 0) {\n            ctx.fillStyle = 'rgba(0,0,0,0.06)';\n            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\n          }\n          break;\n\n        case 1: // Water - animated\n          ctx.fillStyle = `rgba(100,160,255,${0.2 + Math.sin(t / 800 + col * 0.5 + row * 0.3) * 0.1})`;\n          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\n          // Ripple\n          ctx.strokeStyle = `rgba(200,230,255,${0.2 + Math.sin(t / 1000 + col + row) * 0.1})`;\n          ctx.lineWidth = 1;\n          ctx.beginPath();\n          ctx.moveTo(px + 4, py + 16 + Math.sin(t / 500 + col) * 2);\n          ctx.lineTo(px + 28, py + 16 + Math.sin(t / 500 + col + 1) * 2);\n          ctx.stroke();\n          break;\n\n        case 2: // Mountain - rocky texture\n          ctx.fillStyle = '#555555';\n          ctx.fillRect(px + 6, py + 8, 20, 16);\n          ctx.fillStyle = '#888888';\n          ctx.fillRect(px + 10, py + 4, 12, 10);\n          ctx.fillStyle = '#aaaaaa';\n          ctx.fillRect(px + 13, py, 6, 6);\n          break;\n\n        case 3: // Tree\n          // Trunk\n          ctx.fillStyle = '#5a3a1a';\n          ctx.fillRect(px + 13, py + 20, 6, 10);\n          // Canopy\n          ctx.fillStyle = '#1a5c1a';\n          ctx.beginPath();\n          ctx.arc(px + 16, py + 14, 12, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.fillStyle = '#2a7a2a';\n          ctx.beginPath();\n          ctx.arc(px + 14, py + 12, 8, 0, Math.PI * 2);\n          ctx.fill();\n          break;\n\n        case 4: // Path - cobblestone\n          ctx.strokeStyle = 'rgba(0,0,0,0.15)';\n          ctx.lineWidth = 0.5;\n          for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < 3; j++) {\n              ctx.strokeRect(px + 2 + i * 10, py + 2 + j * 10, 8, 8);\n            }\n          }\n          break;\n\n        case 5: // Wall - brick\n          ctx.fillStyle = '#8a6a48';\n          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\n          ctx.fillStyle = 'rgba(0,0,0,0.2)';\n          for (let i = 0; i < 3; i++) {\n            ctx.fillRect(px, py + i * 10 + 1, TILE_SIZE, 2);\n          }\n          break;\n\n        case 6: // Mine - dark entrance\n          ctx.fillStyle = '#222222';\n          ctx.fillRect(px + 6, py + 10, 20, 18);\n          // Mine entrance arch\n          ctx.fillStyle = '#1a1a1a';\n          ctx.beginPath();\n          ctx.arc(px + 16, py + 18, 10, Math.PI, 0);\n          ctx.fill();\n          // Pickaxe icon\n          ctx.fillStyle = '#888';\n          ctx.font = '14px serif';\n          ctx.fillText('â›', px + 9, py + 22);\n          break;\n\n        case 7: // Bank - golden building\n          ctx.fillStyle = '#c8a228';\n          ctx.fillRect(px + 2, py + 6, 28, 22);\n          ctx.fillStyle = '#f5d44a';\n          ctx.fillRect(px + 6, py + 2, 20, 6);\n          // Columns\n          ctx.fillStyle = '#a88822';\n          ctx.fillRect(px + 6, py + 8, 3, 18);\n          ctx.fillRect(px + 23, py + 8, 3, 18);\n          // Door\n          ctx.fillStyle = '#5a3a1a';\n          ctx.fillRect(px + 12, py + 18, 8, 10);\n          break;\n\n        case 8: // Shop - wooden building\n          ctx.fillStyle = '#8a5a30';\n          ctx.fillRect(px + 2, py + 8, 28, 20);\n          // Roof\n          ctx.fillStyle = '#c8701a';\n          ctx.beginPath();\n          ctx.moveTo(px, py + 10);\n          ctx.lineTo(px + 16, py);\n          ctx.lineTo(px + 32, py + 10);\n          ctx.fill();\n          // Window\n          ctx.fillStyle = '#88ccdd';\n          ctx.fillRect(px + 6, py + 12, 8, 8);\n          // Door\n          ctx.fillStyle = '#3a2010';\n          ctx.fillRect(px + 18, py + 18, 8, 10);\n          break;\n\n        case 10: // Flower\n          ctx.fillStyle = '#ff8800';\n          ctx.beginPath();\n          ctx.arc(px + 16, py + 16, 4, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.fillStyle = '#ffdd00';\n          ctx.beginPath();\n          ctx.arc(px + 16, py + 16, 2, 0, Math.PI * 2);\n          ctx.fill();\n          break;\n      }\n\n      // Tile grid (subtle)\n      ctx.strokeStyle = 'rgba(0,0,0,0.05)';\n      ctx.lineWidth = 0.5;\n      ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);\n    },\n\n    renderWorldItems(ctx) {\n      const t = this.animTick;\n      this.worldItems.forEach(item => {\n        const px = item.col * TILE_SIZE;\n        const py = item.row * TILE_SIZE;\n        const bobY = Math.sin(t / 600 + item.col * 0.7) * 2;\n\n        // Glow\n        ctx.shadowColor = item.color || '#ffffff';\n        ctx.shadowBlur = 8;\n        ctx.fillStyle = item.color || '#ffcc00';\n        ctx.beginPath();\n        ctx.arc(px + TILE_SIZE / 2, py + TILE_SIZE / 2 + bobY, 5, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.shadowBlur = 0;\n\n        // Emoji\n        ctx.font = '14px serif';\n        ctx.textAlign = 'center';\n        ctx.fillText(item.emoji || 'ðŸ“¦', px + 16, py + 20 + bobY);\n      });\n      ctx.textAlign = 'left';\n    },\n\n    renderNPCs(ctx) {\n      const t = this.animTick;\n      this.npcs.forEach(npc => {\n        const bobY = npc.moving ? Math.sin(t / 200) * 2 : 0;\n\n        // Shadow\n        ctx.fillStyle = 'rgba(0,0,0,0.3)';\n        ctx.beginPath();\n        ctx.ellipse(npc.x, npc.y + 14, 12, 5, 0, 0, Math.PI * 2);\n        ctx.fill();\n\n        // NPC body\n        ctx.fillStyle = npc.color || '#4488cc';\n        ctx.beginPath();\n        ctx.arc(npc.x, npc.y - 2 + bobY, 14, 0, Math.PI * 2);\n        ctx.fill();\n\n        // NPC emoji\n        ctx.font = '18px serif';\n        ctx.textAlign = 'center';\n        ctx.fillText(npc.emoji || 'ðŸ‘¤', npc.x, npc.y + 7 + bobY);\n\n        // Name tag\n        ctx.font = 'bold 10px Inter, sans-serif';\n        ctx.textAlign = 'center';\n        const nameWidth = ctx.measureText(npc.name).width + 8;\n        ctx.fillStyle = 'rgba(0,0,0,0.6)';\n        ctx.fillRect(npc.x - nameWidth / 2, npc.y - 28 + bobY, nameWidth, 14);\n        ctx.fillStyle = '#ffffff';\n        ctx.fillText(npc.name, npc.x, npc.y - 17 + bobY);\n\n        // Type indicator\n        let typeIcon = '';\n        if (npc.type === 'shop') typeIcon = 'ðŸ›’';\n        else if (npc.type === 'bank') typeIcon = 'ðŸ¦';\n        if (typeIcon) {\n          ctx.font = '10px serif';\n          ctx.fillText(typeIcon, npc.x + 14, npc.y - 14 + bobY);\n        }\n      });\n      ctx.textAlign = 'left';\n    },\n\n    renderOtherPlayers(ctx) {\n      const t = this.animTick;\n      this.otherPlayers.forEach(p => {\n        this.renderCharacter(ctx, p, false, t);\n      });\n    },\n\n    renderPlayer(ctx) {\n      const p = this.player;\n      if (!p || !p.x) return;\n      this.renderCharacter(ctx, p, true, this.animTick);\n    },\n\n    renderCharacter(ctx, p, isMe, t) {\n      const px = p.x;\n      const py = p.y;\n\n      // Shadow\n      ctx.fillStyle = 'rgba(0,0,0,0.25)';\n      ctx.beginPath();\n      ctx.ellipse(px, py + 14, 12, 4, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Body (legs animation)\n      if (p.moving) {\n        // Left leg\n        ctx.fillStyle = '#333';\n        ctx.fillRect(px - 6, py + 4, 5, 10 + Math.sin(t / 150) * 4);\n        // Right leg\n        ctx.fillRect(px + 1, py + 4, 5, 10 - Math.sin(t / 150) * 4);\n      } else {\n        ctx.fillStyle = '#333';\n        ctx.fillRect(px - 6, py + 4, 11, 10);\n      }\n\n      // Torso\n      ctx.fillStyle = isMe ? '#2266cc' : '#cc6622';\n      ctx.fillRect(px - 9, py - 8, 18, 14);\n\n      // Head\n      ctx.fillStyle = '#ffcc99';\n      ctx.beginPath();\n      ctx.arc(px, py - 14, 10, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Eyes based on direction\n      ctx.fillStyle = '#333';\n      if (p.direction === 'south' || !p.direction) {\n        ctx.beginPath();\n        ctx.arc(px - 3, py - 15, 2, 0, Math.PI * 2);\n        ctx.arc(px + 3, py - 15, 2, 0, Math.PI * 2);\n        ctx.fill();\n      } else if (p.direction === 'north') {\n        // Back of head, no eyes\n      } else if (p.direction === 'east') {\n        ctx.beginPath();\n        ctx.arc(px + 4, py - 14, 2, 0, Math.PI * 2);\n        ctx.fill();\n      } else if (p.direction === 'west') {\n        ctx.beginPath();\n        ctx.arc(px - 4, py - 14, 2, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      // Player glow if \"me\"\n      if (isMe) {\n        const emotionColors = {\n          happy: 'rgba(255, 220, 0, 0.8)',\n          sad: 'rgba(0, 100, 255, 0.8)',\n          angry: 'rgba(255, 0, 0, 0.8)',\n          fear: 'rgba(150, 0, 255, 0.8)',\n          neutral: 'rgba(100, 180, 255, 0.8)',\n        };\n        const glowColor = emotionColors[p.emotion] || emotionColors.neutral;\n        \n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = 12;\n        ctx.strokeStyle = glowColor;\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.arc(px, py - 14, 12, 0, Math.PI * 2);\n        ctx.stroke();\n        ctx.shadowBlur = 0;\n      }\n\n      // Name tag\n      ctx.font = 'bold 11px Inter, sans-serif';\n      ctx.textAlign = 'center';\n      const nameW = ctx.measureText(p.name).width + 10;\n\n      ctx.fillStyle = isMe ? 'rgba(20,60,120,0.8)' : 'rgba(0,0,0,0.7)';\n      ctx.fillRect(px - nameW / 2, py - 34, nameW, 16);\n\n      ctx.fillStyle = isMe ? '#88ccff' : '#ffffff';\n      ctx.fillText(p.name, px, py - 22);\n\n      // Health bar\n      if (p.health !== undefined && p.maxHealth > 0) {\n        const barW = 32;\n        const barH = 3;\n        const barX = px - barW / 2;\n        const barY = py - 38;\n        const pct = p.health / p.maxHealth;\n\n        ctx.fillStyle = 'rgba(0,0,0,0.5)';\n        ctx.fillRect(barX, barY, barW, barH);\n        ctx.fillStyle = pct > 0.5 ? '#44dd44' : pct > 0.25 ? '#dddd44' : '#dd4444';\n        ctx.fillRect(barX, barY, barW * pct, barH);\n      }\n\n      ctx.textAlign = 'left';\n    },\n\n    renderHoverHighlight(ctx) {\n      if (this.mouseCol < 0 || this.mouseRow < 0) return;\n      const px = this.mouseCol * TILE_SIZE;\n      const py = this.mouseRow * TILE_SIZE;\n      ctx.strokeStyle = 'rgba(255,255,100,0.5)';\n      ctx.lineWidth = 2;\n      ctx.strokeRect(px + 1, py + 1, TILE_SIZE - 2, TILE_SIZE - 2);\n    },\n\n    renderNightOverlay(ctx, w, h) {\n      if (!this.survival) return;\n      const b = this.survival.brightness;\n      if (b >= 1) return;\n\n      ctx.fillStyle = `rgba(0, 0, 20, ${1 - b})`;\n      ctx.fillRect(0, 0, w, h);\n    },\n\n    // Convert screen coords to world tile\n    screenToTile(screenX, screenY) {\n      const worldX = screenX + this.cameraX;\n      const worldY = screenY + this.cameraY;\n      return {\n        col: Math.floor(worldX / TILE_SIZE),\n        row: Math.floor(worldY / TILE_SIZE),\n      };\n    },\n\n    handleClick(e) {\n      const rect = this.canvas.getBoundingClientRect();\n      const screenX = e.clientX - rect.left;\n      const screenY = e.clientY - rect.top;\n      const { col, row } = this.screenToTile(screenX, screenY);\n\n      // Check if clicking on an NPC\n      const clickedNPC = this.getNearbyEntity(col, row, 'npc');\n      if (clickedNPC) {\n        wsService.interact(clickedNPC.id, 'npc');\n        return;\n      }\n\n      // Check if clicking on a world item\n      const clickedItem = this.getNearbyEntity(col, row, 'item');\n      if (clickedItem) {\n        wsService.interact(clickedItem.id, 'item');\n        return;\n      }\n\n      // Otherwise move to that tile\n      wsService.moveRequest(col, row);\n    },\n\n    handleRightClick(e) {\n      const rect = this.canvas.getBoundingClientRect();\n      const screenX = e.clientX - rect.left;\n      const screenY = e.clientY - rect.top;\n      const { col, row } = this.screenToTile(screenX, screenY);\n\n      // Collect context options\n      const options = [];\n\n      // Check NPC\n      const npc = this.getNearbyEntity(col, row, 'npc');\n      if (npc) {\n        if (npc.type === 'shop') options.push({ label: `ðŸ›’ Trade with ${npc.name}`, action: () => wsService.interact(npc.id, 'npc') });\n        else if (npc.type === 'bank') options.push({ label: `ðŸ¦ Bank with ${npc.name}`, action: () => wsService.interact(npc.id, 'npc') });\n        else options.push({ label: `ðŸ’¬ Talk to ${npc.name}`, action: () => wsService.interact(npc.id, 'npc') });\n      }\n\n      // Check world item\n      const item = this.getNearbyEntity(col, row, 'item');\n      if (item) {\n        options.push({ label: `âœ‹ Pick up ${item.name}`, action: () => wsService.interact(item.id, 'item') });\n      }\n\n      // Check for resource zones\n      const zoneOption = this.getZoneOption(col, row);\n      if (zoneOption) options.push(zoneOption);\n\n      // Walk here\n      options.push({ label: `ðŸš¶ Walk here`, action: () => wsService.moveRequest(col, row) });\n\n      // Survival Options\n      if (this.survival && this.survival.dynamicTiles) {\n        const isDynamic = this.survival.dynamicTiles[`${col},${row}`] !== undefined;\n        if (isDynamic) {\n          options.push({ label: `â›ï¸ Mine this block`, action: () => wsService.action('mine', { args: [col, row] }) });\n        } else {\n          options.push({ label: 'ðŸ•³ï¸ Dig here', action: () => wsService.action('dig', { args: [col, row] }) });\n          \n          const hasWood = this.$store.state.inventory.items.some(i => i.defKey === 'WOOD');\n          if (hasWood) {\n            options.push({ label: 'ðŸ§± Place Wood', action: () => wsService.action('place', { args: ['wood', col, row] }) });\n          }\n          options.push({ label: 'ðŸ  Build Shelter', action: () => wsService.action('house', { args: [] }) });\n        }\n      }\n\n      // Show context menu\n      if (options.length > 0) {\n        this.$root.$emit('show-context-menu', {\n          event: e,\n          type: npc ? 'npc' : (item ? 'worldItem' : 'walk'),\n          npc,\n          worldItem: item,\n          options,\n          col,\n          row\n        });\n      }\n    },\n\n    handleMouseMove(e) {\n      const rect = this.canvas.getBoundingClientRect();\n      const { col, row } = this.screenToTile(e.clientX - rect.left, e.clientY - rect.top);\n      this.mouseCol = col;\n      this.mouseRow = row;\n    },\n\n    getNearbyEntity(col, row, type) {\n      const maxDist = 2;\n      if (type === 'npc') {\n        return this.npcs.find(n => Math.abs(n.col - col) <= maxDist && Math.abs(n.row - row) <= maxDist) || null;\n      }\n      if (type === 'item') {\n        return this.worldItems.find(i => Math.abs(i.col - col) <= maxDist && Math.abs(i.row - row) <= maxDist) || null;\n      }\n      return null;\n    },\n\n    getZoneOption(col, row) {\n      // Match to respawn zones\n      const zones = {\n        FOREST_1: { col: 14, row: 2, radius: 2, label: 'ðŸª“ Chop Wood' },\n        FOREST_2: { col: 26, row: 3, radius: 2, label: 'ðŸª“ Chop Wood' },\n        DIG_SITE: { col: 7, row: 8, radius: 2, label: 'â›ï¸ Dig for Gems' },\n        IRON_MINE: { col: 5, row: 5, radius: 3, label: 'â›ï¸ Mine Iron Ore' },\n        GOLD_MINE: { col: 8, row: 3, radius: 2, label: 'â›ï¸ Mine Gold Ore' },\n        FISHING_SPOT: { col: 2, row: 18, radius: 2, label: 'ðŸŽ£ Fish here' },\n        GRAVEYARD: { col: 34, row: 26, radius: 3, label: 'ðŸ¦´ Gather bones' },\n        SHEEP_FLOCK: { col: 22, row: 8, radius: 3, label: 'âš”ï¸ Attack Sheep' },\n        CREEPER_NEST: { col: 10, row: 20, radius: 2, label: 'ðŸ’¥ Kill Creeper' },\n      };\n\n      for (const [key, zone] of Object.entries(zones)) {\n        if (Math.abs(col - zone.col) <= zone.radius && Math.abs(row - zone.row) <= zone.radius) {\n          return {\n            label: zone.label,\n            action: () => wsService.gather(null, key),\n          };\n        }\n      }\n      return null;\n    },\n  },\n};\n",{"version":3,"sources":["GameCanvas.vue"],"names":[],"mappings":";AAWA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"GameCanvas.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <canvas\n    ref=\"canvas\"\n    id=\"game-canvas\"\n    @click=\"handleClick\"\n    @contextmenu.prevent=\"handleRightClick\"\n    @mousemove=\"handleMouseMove\"\n  ></canvas>\n</template>\n\n<script>\nimport wsService from '../services/websocket';\n\nconst TILE_SIZE = 32;\nconst TILE_COLORS = {\n  0: '#4a7c3f',   // grass\n  1: '#2b5eab',   // water\n  2: '#6e6e6e',   // mountain\n  3: '#2d5a1b',   // tree\n  4: '#8b7355',   // path\n  5: '#a08060',   // wall\n  6: '#444444',   // mine\n  7: '#c8a228',   // bank\n  8: '#8a5a2a',   // shop\n  9: '#c8b87a',   // sand\n  10: '#5a8f3a',  // flower\n};\n\n\nexport default {\n  name: 'GameCanvas',\n  data() {\n    return {\n      canvas: null,\n      ctx: null,\n      animFrame: null,\n      cameraX: 0,\n      cameraY: 0,\n      mouseCol: -1,\n      mouseRow: -1,\n      animTick: 0,\n      lastFrame: 0,\n      // Pre-compute map for rendering\n      worldMap: null,\n      hoverEntity: null,\n    };\n  },\n  computed: {\n    player() {\n      return this.$store.state.player;\n    },\n    otherPlayers() {\n      return this.$store.state.world.otherPlayers;\n    },\n    npcs() {\n      return this.$store.state.world.npcs;\n    },\n    worldItems() {\n      return this.$store.state.world.worldItems;\n    },\n    survival() {\n      return this.$store.state.world.survival;\n    },\n  },\n  mounted() {\n    this.canvas = this.$refs.canvas;\n    this.ctx = this.canvas.getContext('2d');\n    this.resize();\n    window.addEventListener('resize', this.resize);\n\n    // Import map from constants\n    import(/* webpackChunkName: \"constants\" */ '../../server/shared/constants.js')\n      .catch(() => {\n        // Fallback: generate a simple map\n        this.worldMap = this.generateFallbackMap();\n      })\n      .then((mod) => {\n        if (mod) this.worldMap = mod.WORLD_MAP;\n        this.startLoop();\n      });\n  },\n  beforeDestroy() {\n    window.removeEventListener('resize', this.resize);\n    if (this.animFrame) cancelAnimationFrame(this.animFrame);\n  },\n  methods: {\n    resize() {\n      const container = this.$el.parentElement;\n      this.canvas.width = container.clientWidth;\n      this.canvas.height = container.clientHeight;\n    },\n\n    generateFallbackMap() {\n      // 40x32 grass map with paths and water\n      const cols = 40, rows = 32;\n      const map = [];\n      for (let r = 0; r < rows; r++) {\n        const row = [];\n        for (let c = 0; c < cols; c++) {\n          if (r === 0 || r === rows - 1 || c === 0 || c === cols - 1) row.push(2);\n          else if (r === 6 || r === 12 || r === 20) row.push(4);\n          else if (c === 19) row.push(4);\n          else if (c < 4 && r > 12 && r < 22) row.push(1);\n          else row.push(0);\n        }\n        map.push(row);\n      }\n      return map;\n    },\n\n    startLoop() {\n      const loop = (timestamp) => {\n        const delta = timestamp - this.lastFrame;\n        this.lastFrame = timestamp;\n        this.animTick = timestamp;\n        this.update(delta);\n        this.render();\n        this.animFrame = requestAnimationFrame(loop);\n      };\n      this.animFrame = requestAnimationFrame(loop);\n    },\n\n    update() {\n      // Update camera to follow player\n      if (!this.player || !this.canvas) return;\n\n      const targetCamX = this.player.x - this.canvas.width / 2;\n      const targetCamY = this.player.y - this.canvas.height / 2;\n\n      // Smooth camera\n      const lerp = 0.12;\n      this.cameraX += (targetCamX - this.cameraX) * lerp;\n      this.cameraY += (targetCamY - this.cameraY) * lerp;\n\n      // Clamp camera\n      if (this.worldMap) {\n        const mapW = this.worldMap[0].length * TILE_SIZE;\n        const mapH = this.worldMap.length * TILE_SIZE;\n        this.cameraX = Math.max(0, Math.min(this.cameraX, mapW - this.canvas.width));\n        this.cameraY = Math.max(0, Math.min(this.cameraY, mapH - this.canvas.height));\n      }\n    },\n\n    render() {\n      if (!this.ctx || !this.canvas) return;\n      const ctx = this.ctx;\n      const w = this.canvas.width;\n      const h = this.canvas.height;\n\n      ctx.clearRect(0, 0, w, h);\n      ctx.save();\n      ctx.translate(-Math.floor(this.cameraX), -Math.floor(this.cameraY));\n\n      this.renderMap(ctx);\n      this.renderWorldItems(ctx);\n      this.renderNPCs(ctx);\n      this.renderOtherPlayers(ctx);\n      this.renderPlayer(ctx);\n      this.renderHoverHighlight(ctx);\n\n      ctx.restore();\n      \n      this.renderNightOverlay(ctx, w, h);\n    },\n\n    renderMap(ctx) {\n      if (!this.worldMap) return;\n\n      const startCol = Math.max(0, Math.floor(this.cameraX / TILE_SIZE) - 1);\n      const startRow = Math.max(0, Math.floor(this.cameraY / TILE_SIZE) - 1);\n      const endCol = Math.min(this.worldMap[0].length, startCol + Math.ceil(this.canvas.width / TILE_SIZE) + 2);\n      const endRow = Math.min(this.worldMap.length, startRow + Math.ceil(this.canvas.height / TILE_SIZE) + 2);\n\n      for (let row = startRow; row < endRow; row++) {\n        for (let col = startCol; col < endCol; col++) {\n          let tile = this.worldMap[row][col];\n          \n          // Check dynamic tiles\n          if (this.survival && this.survival.dynamicTiles) {\n            const dynamicTile = this.survival.dynamicTiles[`${col},${row}`];\n            if (dynamicTile !== undefined) tile = dynamicTile;\n          }\n\n          const px = col * TILE_SIZE;\n          const py = row * TILE_SIZE;\n\n          // Base tile color\n          ctx.fillStyle = TILE_COLORS[tile] || '#444';\n          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\n\n          // Tile details/decorations\n          this.renderTileDetail(ctx, tile, px, py, col, row);\n        }\n      }\n    },\n\n    renderTileDetail(ctx, tile, px, py, col, row) {\n      const t = this.animTick;\n\n      switch(tile) {\n        case 0: // Grass - subtle variation\n          if ((col + row) % 3 === 0) {\n            ctx.fillStyle = 'rgba(0,0,0,0.06)';\n            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\n          }\n          break;\n\n        case 1: // Water - animated\n          ctx.fillStyle = `rgba(100,160,255,${0.2 + Math.sin(t / 800 + col * 0.5 + row * 0.3) * 0.1})`;\n          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\n          // Ripple\n          ctx.strokeStyle = `rgba(200,230,255,${0.2 + Math.sin(t / 1000 + col + row) * 0.1})`;\n          ctx.lineWidth = 1;\n          ctx.beginPath();\n          ctx.moveTo(px + 4, py + 16 + Math.sin(t / 500 + col) * 2);\n          ctx.lineTo(px + 28, py + 16 + Math.sin(t / 500 + col + 1) * 2);\n          ctx.stroke();\n          break;\n\n        case 2: // Mountain - rocky texture\n          ctx.fillStyle = '#555555';\n          ctx.fillRect(px + 6, py + 8, 20, 16);\n          ctx.fillStyle = '#888888';\n          ctx.fillRect(px + 10, py + 4, 12, 10);\n          ctx.fillStyle = '#aaaaaa';\n          ctx.fillRect(px + 13, py, 6, 6);\n          break;\n\n        case 3: // Tree\n          // Trunk\n          ctx.fillStyle = '#5a3a1a';\n          ctx.fillRect(px + 13, py + 20, 6, 10);\n          // Canopy\n          ctx.fillStyle = '#1a5c1a';\n          ctx.beginPath();\n          ctx.arc(px + 16, py + 14, 12, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.fillStyle = '#2a7a2a';\n          ctx.beginPath();\n          ctx.arc(px + 14, py + 12, 8, 0, Math.PI * 2);\n          ctx.fill();\n          break;\n\n        case 4: // Path - cobblestone\n          ctx.strokeStyle = 'rgba(0,0,0,0.15)';\n          ctx.lineWidth = 0.5;\n          for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < 3; j++) {\n              ctx.strokeRect(px + 2 + i * 10, py + 2 + j * 10, 8, 8);\n            }\n          }\n          break;\n\n        case 5: // Wall - brick\n          ctx.fillStyle = '#8a6a48';\n          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);\n          ctx.fillStyle = 'rgba(0,0,0,0.2)';\n          for (let i = 0; i < 3; i++) {\n            ctx.fillRect(px, py + i * 10 + 1, TILE_SIZE, 2);\n          }\n          break;\n\n        case 6: // Mine - dark entrance\n          ctx.fillStyle = '#222222';\n          ctx.fillRect(px + 6, py + 10, 20, 18);\n          // Mine entrance arch\n          ctx.fillStyle = '#1a1a1a';\n          ctx.beginPath();\n          ctx.arc(px + 16, py + 18, 10, Math.PI, 0);\n          ctx.fill();\n          // Pickaxe icon\n          ctx.fillStyle = '#888';\n          ctx.font = '14px serif';\n          ctx.fillText('â›', px + 9, py + 22);\n          break;\n\n        case 7: // Bank - golden building\n          ctx.fillStyle = '#c8a228';\n          ctx.fillRect(px + 2, py + 6, 28, 22);\n          ctx.fillStyle = '#f5d44a';\n          ctx.fillRect(px + 6, py + 2, 20, 6);\n          // Columns\n          ctx.fillStyle = '#a88822';\n          ctx.fillRect(px + 6, py + 8, 3, 18);\n          ctx.fillRect(px + 23, py + 8, 3, 18);\n          // Door\n          ctx.fillStyle = '#5a3a1a';\n          ctx.fillRect(px + 12, py + 18, 8, 10);\n          break;\n\n        case 8: // Shop - wooden building\n          ctx.fillStyle = '#8a5a30';\n          ctx.fillRect(px + 2, py + 8, 28, 20);\n          // Roof\n          ctx.fillStyle = '#c8701a';\n          ctx.beginPath();\n          ctx.moveTo(px, py + 10);\n          ctx.lineTo(px + 16, py);\n          ctx.lineTo(px + 32, py + 10);\n          ctx.fill();\n          // Window\n          ctx.fillStyle = '#88ccdd';\n          ctx.fillRect(px + 6, py + 12, 8, 8);\n          // Door\n          ctx.fillStyle = '#3a2010';\n          ctx.fillRect(px + 18, py + 18, 8, 10);\n          break;\n\n        case 10: // Flower\n          ctx.fillStyle = '#ff8800';\n          ctx.beginPath();\n          ctx.arc(px + 16, py + 16, 4, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.fillStyle = '#ffdd00';\n          ctx.beginPath();\n          ctx.arc(px + 16, py + 16, 2, 0, Math.PI * 2);\n          ctx.fill();\n          break;\n      }\n\n      // Tile grid (subtle)\n      ctx.strokeStyle = 'rgba(0,0,0,0.05)';\n      ctx.lineWidth = 0.5;\n      ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);\n    },\n\n    renderWorldItems(ctx) {\n      const t = this.animTick;\n      this.worldItems.forEach(item => {\n        const px = item.col * TILE_SIZE;\n        const py = item.row * TILE_SIZE;\n        const bobY = Math.sin(t / 600 + item.col * 0.7) * 2;\n\n        // Glow\n        ctx.shadowColor = item.color || '#ffffff';\n        ctx.shadowBlur = 8;\n        ctx.fillStyle = item.color || '#ffcc00';\n        ctx.beginPath();\n        ctx.arc(px + TILE_SIZE / 2, py + TILE_SIZE / 2 + bobY, 5, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.shadowBlur = 0;\n\n        // Emoji\n        ctx.font = '14px serif';\n        ctx.textAlign = 'center';\n        ctx.fillText(item.emoji || 'ðŸ“¦', px + 16, py + 20 + bobY);\n      });\n      ctx.textAlign = 'left';\n    },\n\n    renderNPCs(ctx) {\n      const t = this.animTick;\n      this.npcs.forEach(npc => {\n        const bobY = npc.moving ? Math.sin(t / 200) * 2 : 0;\n\n        // Shadow\n        ctx.fillStyle = 'rgba(0,0,0,0.3)';\n        ctx.beginPath();\n        ctx.ellipse(npc.x, npc.y + 14, 12, 5, 0, 0, Math.PI * 2);\n        ctx.fill();\n\n        // NPC body\n        ctx.fillStyle = npc.color || '#4488cc';\n        ctx.beginPath();\n        ctx.arc(npc.x, npc.y - 2 + bobY, 14, 0, Math.PI * 2);\n        ctx.fill();\n\n        // NPC emoji\n        ctx.font = '18px serif';\n        ctx.textAlign = 'center';\n        ctx.fillText(npc.emoji || 'ðŸ‘¤', npc.x, npc.y + 7 + bobY);\n\n        // Name tag\n        ctx.font = 'bold 10px Inter, sans-serif';\n        ctx.textAlign = 'center';\n        const nameWidth = ctx.measureText(npc.name).width + 8;\n        ctx.fillStyle = 'rgba(0,0,0,0.6)';\n        ctx.fillRect(npc.x - nameWidth / 2, npc.y - 28 + bobY, nameWidth, 14);\n        ctx.fillStyle = '#ffffff';\n        ctx.fillText(npc.name, npc.x, npc.y - 17 + bobY);\n\n        // Type indicator\n        let typeIcon = '';\n        if (npc.type === 'shop') typeIcon = 'ðŸ›’';\n        else if (npc.type === 'bank') typeIcon = 'ðŸ¦';\n        if (typeIcon) {\n          ctx.font = '10px serif';\n          ctx.fillText(typeIcon, npc.x + 14, npc.y - 14 + bobY);\n        }\n      });\n      ctx.textAlign = 'left';\n    },\n\n    renderOtherPlayers(ctx) {\n      const t = this.animTick;\n      this.otherPlayers.forEach(p => {\n        this.renderCharacter(ctx, p, false, t);\n      });\n    },\n\n    renderPlayer(ctx) {\n      const p = this.player;\n      if (!p || !p.x) return;\n      this.renderCharacter(ctx, p, true, this.animTick);\n    },\n\n    renderCharacter(ctx, p, isMe, t) {\n      const px = p.x;\n      const py = p.y;\n\n      // Shadow\n      ctx.fillStyle = 'rgba(0,0,0,0.25)';\n      ctx.beginPath();\n      ctx.ellipse(px, py + 14, 12, 4, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Body (legs animation)\n      if (p.moving) {\n        // Left leg\n        ctx.fillStyle = '#333';\n        ctx.fillRect(px - 6, py + 4, 5, 10 + Math.sin(t / 150) * 4);\n        // Right leg\n        ctx.fillRect(px + 1, py + 4, 5, 10 - Math.sin(t / 150) * 4);\n      } else {\n        ctx.fillStyle = '#333';\n        ctx.fillRect(px - 6, py + 4, 11, 10);\n      }\n\n      // Torso\n      ctx.fillStyle = isMe ? '#2266cc' : '#cc6622';\n      ctx.fillRect(px - 9, py - 8, 18, 14);\n\n      // Head\n      ctx.fillStyle = '#ffcc99';\n      ctx.beginPath();\n      ctx.arc(px, py - 14, 10, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Eyes based on direction\n      ctx.fillStyle = '#333';\n      if (p.direction === 'south' || !p.direction) {\n        ctx.beginPath();\n        ctx.arc(px - 3, py - 15, 2, 0, Math.PI * 2);\n        ctx.arc(px + 3, py - 15, 2, 0, Math.PI * 2);\n        ctx.fill();\n      } else if (p.direction === 'north') {\n        // Back of head, no eyes\n      } else if (p.direction === 'east') {\n        ctx.beginPath();\n        ctx.arc(px + 4, py - 14, 2, 0, Math.PI * 2);\n        ctx.fill();\n      } else if (p.direction === 'west') {\n        ctx.beginPath();\n        ctx.arc(px - 4, py - 14, 2, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      // Player glow if \"me\"\n      if (isMe) {\n        const emotionColors = {\n          happy: 'rgba(255, 220, 0, 0.8)',\n          sad: 'rgba(0, 100, 255, 0.8)',\n          angry: 'rgba(255, 0, 0, 0.8)',\n          fear: 'rgba(150, 0, 255, 0.8)',\n          neutral: 'rgba(100, 180, 255, 0.8)',\n        };\n        const glowColor = emotionColors[p.emotion] || emotionColors.neutral;\n        \n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = 12;\n        ctx.strokeStyle = glowColor;\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.arc(px, py - 14, 12, 0, Math.PI * 2);\n        ctx.stroke();\n        ctx.shadowBlur = 0;\n      }\n\n      // Name tag\n      ctx.font = 'bold 11px Inter, sans-serif';\n      ctx.textAlign = 'center';\n      const nameW = ctx.measureText(p.name).width + 10;\n\n      ctx.fillStyle = isMe ? 'rgba(20,60,120,0.8)' : 'rgba(0,0,0,0.7)';\n      ctx.fillRect(px - nameW / 2, py - 34, nameW, 16);\n\n      ctx.fillStyle = isMe ? '#88ccff' : '#ffffff';\n      ctx.fillText(p.name, px, py - 22);\n\n      // Health bar\n      if (p.health !== undefined && p.maxHealth > 0) {\n        const barW = 32;\n        const barH = 3;\n        const barX = px - barW / 2;\n        const barY = py - 38;\n        const pct = p.health / p.maxHealth;\n\n        ctx.fillStyle = 'rgba(0,0,0,0.5)';\n        ctx.fillRect(barX, barY, barW, barH);\n        ctx.fillStyle = pct > 0.5 ? '#44dd44' : pct > 0.25 ? '#dddd44' : '#dd4444';\n        ctx.fillRect(barX, barY, barW * pct, barH);\n      }\n\n      ctx.textAlign = 'left';\n    },\n\n    renderHoverHighlight(ctx) {\n      if (this.mouseCol < 0 || this.mouseRow < 0) return;\n      const px = this.mouseCol * TILE_SIZE;\n      const py = this.mouseRow * TILE_SIZE;\n      ctx.strokeStyle = 'rgba(255,255,100,0.5)';\n      ctx.lineWidth = 2;\n      ctx.strokeRect(px + 1, py + 1, TILE_SIZE - 2, TILE_SIZE - 2);\n    },\n\n    renderNightOverlay(ctx, w, h) {\n      if (!this.survival) return;\n      const b = this.survival.brightness;\n      if (b >= 1) return;\n\n      ctx.fillStyle = `rgba(0, 0, 20, ${1 - b})`;\n      ctx.fillRect(0, 0, w, h);\n    },\n\n    // Convert screen coords to world tile\n    screenToTile(screenX, screenY) {\n      const worldX = screenX + this.cameraX;\n      const worldY = screenY + this.cameraY;\n      return {\n        col: Math.floor(worldX / TILE_SIZE),\n        row: Math.floor(worldY / TILE_SIZE),\n      };\n    },\n\n    handleClick(e) {\n      const rect = this.canvas.getBoundingClientRect();\n      const screenX = e.clientX - rect.left;\n      const screenY = e.clientY - rect.top;\n      const { col, row } = this.screenToTile(screenX, screenY);\n\n      // Check if clicking on an NPC\n      const clickedNPC = this.getNearbyEntity(col, row, 'npc');\n      if (clickedNPC) {\n        wsService.interact(clickedNPC.id, 'npc');\n        return;\n      }\n\n      // Check if clicking on a world item\n      const clickedItem = this.getNearbyEntity(col, row, 'item');\n      if (clickedItem) {\n        wsService.interact(clickedItem.id, 'item');\n        return;\n      }\n\n      // Otherwise move to that tile\n      wsService.moveRequest(col, row);\n    },\n\n    handleRightClick(e) {\n      const rect = this.canvas.getBoundingClientRect();\n      const screenX = e.clientX - rect.left;\n      const screenY = e.clientY - rect.top;\n      const { col, row } = this.screenToTile(screenX, screenY);\n\n      // Collect context options\n      const options = [];\n\n      // Check NPC\n      const npc = this.getNearbyEntity(col, row, 'npc');\n      if (npc) {\n        if (npc.type === 'shop') options.push({ label: `ðŸ›’ Trade with ${npc.name}`, action: () => wsService.interact(npc.id, 'npc') });\n        else if (npc.type === 'bank') options.push({ label: `ðŸ¦ Bank with ${npc.name}`, action: () => wsService.interact(npc.id, 'npc') });\n        else options.push({ label: `ðŸ’¬ Talk to ${npc.name}`, action: () => wsService.interact(npc.id, 'npc') });\n      }\n\n      // Check world item\n      const item = this.getNearbyEntity(col, row, 'item');\n      if (item) {\n        options.push({ label: `âœ‹ Pick up ${item.name}`, action: () => wsService.interact(item.id, 'item') });\n      }\n\n      // Check for resource zones\n      const zoneOption = this.getZoneOption(col, row);\n      if (zoneOption) options.push(zoneOption);\n\n      // Walk here\n      options.push({ label: `ðŸš¶ Walk here`, action: () => wsService.moveRequest(col, row) });\n\n      // Survival Options\n      if (this.survival && this.survival.dynamicTiles) {\n        const isDynamic = this.survival.dynamicTiles[`${col},${row}`] !== undefined;\n        if (isDynamic) {\n          options.push({ label: `â›ï¸ Mine this block`, action: () => wsService.action('mine', { args: [col, row] }) });\n        } else {\n          options.push({ label: 'ðŸ•³ï¸ Dig here', action: () => wsService.action('dig', { args: [col, row] }) });\n          \n          const hasWood = this.$store.state.inventory.items.some(i => i.defKey === 'WOOD');\n          if (hasWood) {\n            options.push({ label: 'ðŸ§± Place Wood', action: () => wsService.action('place', { args: ['wood', col, row] }) });\n          }\n          options.push({ label: 'ðŸ  Build Shelter', action: () => wsService.action('house', { args: [] }) });\n        }\n      }\n\n      // Show context menu\n      if (options.length > 0) {\n        this.$root.$emit('show-context-menu', {\n          event: e,\n          type: npc ? 'npc' : (item ? 'worldItem' : 'walk'),\n          npc,\n          worldItem: item,\n          options,\n          col,\n          row\n        });\n      }\n    },\n\n    handleMouseMove(e) {\n      const rect = this.canvas.getBoundingClientRect();\n      const { col, row } = this.screenToTile(e.clientX - rect.left, e.clientY - rect.top);\n      this.mouseCol = col;\n      this.mouseRow = row;\n    },\n\n    getNearbyEntity(col, row, type) {\n      const maxDist = 2;\n      if (type === 'npc') {\n        return this.npcs.find(n => Math.abs(n.col - col) <= maxDist && Math.abs(n.row - row) <= maxDist) || null;\n      }\n      if (type === 'item') {\n        return this.worldItems.find(i => Math.abs(i.col - col) <= maxDist && Math.abs(i.row - row) <= maxDist) || null;\n      }\n      return null;\n    },\n\n    getZoneOption(col, row) {\n      // Match to respawn zones\n      const zones = {\n        FOREST_1: { col: 14, row: 2, radius: 2, label: 'ðŸª“ Chop Wood' },\n        FOREST_2: { col: 26, row: 3, radius: 2, label: 'ðŸª“ Chop Wood' },\n        DIG_SITE: { col: 7, row: 8, radius: 2, label: 'â›ï¸ Dig for Gems' },\n        IRON_MINE: { col: 5, row: 5, radius: 3, label: 'â›ï¸ Mine Iron Ore' },\n        GOLD_MINE: { col: 8, row: 3, radius: 2, label: 'â›ï¸ Mine Gold Ore' },\n        FISHING_SPOT: { col: 2, row: 18, radius: 2, label: 'ðŸŽ£ Fish here' },\n        GRAVEYARD: { col: 34, row: 26, radius: 3, label: 'ðŸ¦´ Gather bones' },\n        SHEEP_FLOCK: { col: 22, row: 8, radius: 3, label: 'âš”ï¸ Attack Sheep' },\n        CREEPER_NEST: { col: 10, row: 20, radius: 2, label: 'ðŸ’¥ Kill Creeper' },\n      };\n\n      for (const [key, zone] of Object.entries(zones)) {\n        if (Math.abs(col - zone.col) <= zone.radius && Math.abs(row - zone.row) <= zone.radius) {\n          return {\n            label: zone.label,\n            action: () => wsService.gather(null, key),\n          };\n        }\n      }\n      return null;\n    },\n  },\n};\n</script>\n\n<style scoped>\n#game-canvas {\n  display: block;\n  width: 100%;\n  height: 100%;\n  cursor: crosshair;\n  image-rendering: pixelated;\n  image-rendering: crisp-edges;\n}\n</style>\n"]}]}